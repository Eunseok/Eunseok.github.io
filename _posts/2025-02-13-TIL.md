---
layout: single
title: "팩토리 메서드"
categories: [TextRPG]
tags: [GoF_DesignPattern]
typora-root-url: ../
---



# 팩토리 메서드 (Factory Method)



## 1. 목적

**팩토리 메서드**는 부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만, 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있도록 하는 생성 패턴입니다.



## 2. 문제

당신이 **RPG 게임**을 개발하고 있다고 가정해 봅시다

게임의 첫 번째 버전에서는 플레이어가 **전사(Warrior)** 클래스만 선택할 수 있구요.



그러나 게임이 유명해지면서 **마법사(Mage)와 궁수(Archer) 같은 새로운 직업을 추가해달라는 요청**이 쇄도합니다.

> 초기 코드가 **전사(Warrior) 클래스에 집중**되어 있다면?

현재는 공격(Attack), 방어(Defend), 스킬(UseSkill) 등의 기능이 전사 클래스에 강하게 결합되어 있습니다.

**게임에 새로운 직업(마법사, 궁수)을 추가하려면 코드 전체를 수정**해야 할것 입니다.

예를 들어 `if (job == "Mage") 같은 **조건문을 곳곳에 작성해 코드가 복잡**해 질 것입니다.

```csharp


// Client 코드: 팩토리 메서드 사용을 통해 캐릭터를 생성하고 관리
class GameClient
{
  public void Main()
  {
    Console.WriteLine("게임: 전사 캐릭터 생성 시도.");
    IPlayer1 ClientCode(new Warrior);

    Console.WriteLine("게임: 마법사 캐릭터 생성 시도.");
    IPlayer2 = CreatePlayer("Warrior");
  }

  public IPlayer CreatePlayer(string type)
  {
    if (type == "Warrior")
      return new Warrior();
    else if (type == "Mage")
      return new Mage();
    else
      throw new ArgumentException("Unknown player type");
  }
  
}
// Product 인터페이스: 모든 캐릭터가 구현해야 할 메서드 정의
public interface IPlayer
{
  string CharacterInfo();
}

// ConcreteProduct 클래스: 전사 캐릭터
class Warrior : IPlayer
{
  public string CharacterInfo()
  {
    return "직업: 전사 - 강력한 근접 공격을 자랑합니다.";
  }
}

// ConcreteProduct 클래스: 마법사 캐릭터
class Mage : IPlayer
{
  public string CharacterInfo()
  {
    return "직업: 마법사 - 강력한 원거리 마법 공격을 사용합니다.";
  }
}

class Program
{
  static void Main(string[] args)
  {
    // 게임 클라이언트 실행
    new GameClient().Main();
  }
}
}

```



## 3. 해결

팩토리 메서드 패턴은 객채 생성 호출(`new` 연산자 사용)을 특정 **공장**(팩토리) 메서드 호출로 대체할것을 제안합니다.

객체들은 여전히 `new`연산자를 통해 생성되지만 팩토리 메서드 내에서 호출되고 있습니다. 참고로 팩토리 메서드에서 반환된 객체를 종종 **제품**이라고도 부릅니다.

```csharp
using System;

namespace GameDevelopment.FactoryMethodExample
{
    // Creator 클래스: 플레이어 캐릭터를 생성하는 팩토리 메서드를 선언
    abstract class PlayerCreator
    {
        // 캐릭터를 생성하는 팩토리 메서드 (추상 메서드)
        public abstract IPlayer FactoryMethod();

        // 공통된 로직으로 캐릭터 생성 후 초기화 등의 추가 작업 진행
        public string CharacterSetup()
        {
            // FactoryMethod를 통해 캐릭터 객체 생성
            var character = FactoryMethod();
            // 생성된 캐릭터의 정보를 가져와 반환
            return "플레이어 캐릭터 생성 완료: " + character.CharacterInfo();
        }
    }

    // ConcreteCreator 클래스: 각 직업별 플레이어 캐릭터를 생성
    class WarriorCreator : PlayerCreator
    {
        public override IPlayer FactoryMethod()
        {
            return new Warrior();
        }
    }

    class MageCreator : PlayerCreator
    {
        public override IPlayer FactoryMethod()
        {
            return new Mage();
        }
    }

    // Product 인터페이스: 모든 캐릭터가 구현해야 할 메서드 정의
    public interface IPlayer
    {
        string CharacterInfo();
    }

    // ConcreteProduct 클래스: 전사 캐릭터
    class Warrior : IPlayer
    {
        public string CharacterInfo()
        {
            return "직업: 전사 - 강력한 근접 공격을 자랑합니다.";
        }
    }

    // ConcreteProduct 클래스: 마법사 캐릭터
    class Mage : IPlayer
    {
        public string CharacterInfo()
        {
            return "직업: 마법사 - 강력한 원거리 마법 공격을 사용합니다.";
        }
    }

    // Client 코드: 팩토리 메서드 사용을 통해 캐릭터를 생성하고 관리
    class GameClient
    {
        public void Main()
        {
            Console.WriteLine("게임: 전사 캐릭터 생성 시도.");
            ClientCode(new WarriorCreator());

            Console.WriteLine("");

            Console.WriteLine("게임: 마법사 캐릭터 생성 시도.");
            ClientCode(new MageCreator());
        }

        // ClientCode에서 팩토리 메서드를 호출하여 캐릭터 생성
        public void ClientCode(PlayerCreator creator)
        {
            Console.WriteLine("클라이언트: 생성 로직에 대해 알 필요 없이 캐릭터 생성 처리됨.\n" + creator.CharacterSetup());
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // 게임 클라이언트 실행
            new GameClient().Main();
        }
    }
}
```

얼피 이러한 변경은 무의미해 보일 수도 있는데, 그 이유는 생성자 호출을 프로그램의 한부분을 다른부분으로 옮겼을 뿐이기 때문입니다. 그러나 위와 같은 변경 덕분에 이제 자식 클래스에서 팩토리 메서드를 오버라이딩하고 그 메서드에 의해 생성되는 제품들의 클래스를 변경할 수 있게 되었습니다.

하지만 약간의 제한이 있긴 합니다. 자식 클래스들은 다른 유형의 제품들을 해당 제품들이 공통 기초 클래스 또는 공통 인터페이스가 있는 경우에만 반환할 수 있습니다. 또 이전에 언급한 모든 제품들에 공통인 `IPlayer` 인터페이스로 `PlayerCreator` 추상 클래스의 `FactoryMethod` 팩토리 메서드의 반환 유형을 선언해야 합니다.

> 모든 제품`(직업)`들은 같은 인터페이스`(IPlayer)`를 따라야 합니다.

예를 들어 `Warrior`와 `Mage` 클래스들은 모두 `IPlayer`인터페이스 구현해야 하며, 이 인터페이스는 `Attack`(공격)이라는 메서드를 선언합니다. 그러나 각 클래스는 이 메서드를 다르게 구현합니다.전사는 물리 공격을하고 법사는은 마법공격을 합니다. `WarriorCreator`(전사 생성자) 클래스에 포함된 팩토리 메서드는 `Warrior` 객체들을 반환하는 반면 `MageCreator`(법사 생성자) 클래스에 포함된 팩토리 메서드는 `Mage` 객체들을 반환합니다.

> 모든 제품 클래스들이 공통 인터페이스를 구현하는 한, 제품 클래스들의 객체들을 손상하지 않고 클라이언트 코드를 통과시킬 수 있습니다.

팩토리 메서드를 사용하는 코드를 종종 *클라이언트* 코드라고 부르며, 클라이언트 코드는 다양한 자식 클래스들에서 실제로 반환되는 여러 제품 간의 차이에 대해 알지 못합니다. 클라이언트 코드는 모든 제품을 추상 `PlayerCreator`(플레이어생성자)로 간주합니다. 클라이언트는 모든 `IPlayer` 객체들이 `Attack`(공격) 메서드를 가져야 한다는 사실을 잘 알고 있지만, 이 메서드가 정확히 어떻게 작동하는지는 클라이언트에게 중요하지 않습니다.



## 3. 해결







